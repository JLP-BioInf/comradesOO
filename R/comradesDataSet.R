#' @include comradesOO.R

#' comradesDataSet
#'
#' An S4 class to represent a COMRADES dataset
#'
#'
#'
#' @rdname comradesDataSet
#'
#' @slot hybFiles desc
#' @slot sampleTable desc
#' @slot rnas desc
#' @slot group desc
#' @slot matrixList desc
#'
#'
#'
#' @export
#'
setClass("comradesDataSet",
         slots = c(
             rnas = "character",
             hybDir = "character",
             sampleTable = "data.frame",    # meta data
             hybFiles = "list",       # data tables
             matrixList = "list",
             group = "list",
             sampleNames = "character" # Column containing control or sample
         ),
         prototype = list(

         ))

setValidity("comradesDataSet", function(object) {

    #test to make sure the object is O.K

})




#' comradesDataSet
#'
#' \code{comradesDataSet} is a subclass of \code{RangedSummarizedExperiment},
#' used to store the input values, intermediate calculations and results of an
#' analysis of differential expression.  The \code{DESeqDataSet} class
#' enforces non-negative integer values in the "counts" matrix stored as
#' the first element in the assay list.
#' In addition, a formula which specifies the design of the experiment must be provided.
#' The constructor functions create a DESeqDataSet object
#' from various types of input:
#' a RangedSummarizedExperiment, a matrix, count files generated by
#' the python package HTSeq, or a list from the tximport function in the
#' tximport package.
#' See the vignette for examples of construction from different types.
#'
#'
#' @param se a \code{RangedSummarizedExperiment} with columns of variables
#' indicating sample information in \code{colData},
#' and the counts as the first element in the assays list, which will
#' be renamed "counts". A \code{RangedSummarizedExperiment} object can be
#' generated by the function \code{summarizeOverlaps} in the GenomicAlignments
#' package.
#' @param design a \code{formula} or \code{matrix}.
#' the \code{formula} expresses how the counts for each gene
#' depend on the variables in \code{colData}. Many R \code{formula} are valid,
#' including designs with multiple variables, e.g., \code{~ group + condition},
#' and designs with interactions, e.g., \code{~ genotype + treatment + genotype:treatment}.
#' See \code{\link{results}} for a variety of designs and how to extract results tables.
#' By default, the functions in this package will use
#' the last variable in the formula for building results tables and plotting.
#' \code{~ 1} can be used for no design, although users need to remember
#' to switch to another design for differential testing.
#' @param countData for matrix input: a matrix of non-negative integers
#' @param colData for matrix input: a \code{DataFrame} or \code{data.frame} with at least a single column.
#' Rows of colData correspond to columns of countData
#' @param tidy for matrix input: whether the first column of countData is the rownames for the count matrix
#' @param sampleTable for htseq-count: a \code{data.frame} with three or more columns. Each row
#' describes one sample. The first column is the sample name, the second column
#' the file name of the count file generated by htseq-count, and the remaining
#' columns are sample metadata which will be stored in \code{colData}
#' @param txi for tximport: the simple list output of the \code{tximport} function
#' @param directory for htseq-count: the directory relative to which the filenames are specified. defaults to current directory
#' @param ignoreRank use of this argument is reserved for DEXSeq developers only.
#' Users will immediately encounter an error upon trying to estimate dispersion
#' using a design with a model matrix which is not full rank.
#' @param ... arguments provided to \code{SummarizedExperiment} including rowRanges and metadata. Note that
#' for Bioconductor 3.1, rowRanges must be a GRanges or GRangesList, with potential metadata columns
#' as a DataFrame accessed and stored with \code{mcols}. If a user wants to store metadata columns
#' about the rows of the countData, but does not have GRanges or GRangesList information,
#' first construct the DESeqDataSet without rowRanges and then add the DataFrame with \code{mcols(dds)}.
#'
#' @return A comradesDataSet object.
#'
#'
#' @references See \url{http://www-huber.embl.de/users/anders/HTSeq} for hyb
#'
#' @docType class
#'
#' @examples
#'
#' countData <- matrix(1:100,ncol=4)
#' condition <- factor(c("A","A","B","B"))
#' dds <- DESeqDataSetFromMatrix(countData, DataFrame(condition), ~ condition)
#'
#' @rdname DESeqDataSet
#' @importFrom utils packageVersion
#' @export

comradesDataSet <- function(rnas,
                            hybDir,
                            sampleTable,
                            group,
                            rnaSize) {
    ###########################################################
    # Read in the sample table
    ###########################################################
    # check the inputs here, stop if wrong
    print(" ***** ******************* ****** ")
    print(" ***** Reading SampleTable ****** ")

    # Read in sample table
    sampleTable = read.table(sampleTable,
                             header = T, stringsAsFactors = F)
    #check for more than two samples
    if( nrow(sampleTable) < 2 ){
        stop( "The sample Table must contain at least 1
              sample and 1 control" )
    }
    print(paste("***  detected ",nrow(sampleTable), " samples  ***"))


    #check column names of sampleTable
    colnamesST = c("file", "group", "sample", "sampleName")
    if(all(colnames( sampleTable ) != colnamesST)){
        stop( "Column names of metaData table should be :
              file, group, sample, sampleNames" )
    }

    ###########################################################
    # Get the comparison groups
    # check group has the c and s
    if(! ( unique(as.character( sampleTable$group ) )[1] %in% c("c", "s") &
           unique(as.character( sampleTable$group ) )[2] %in% c("c", "s") ) ) {
        stop( "Groups should be c and s" )
    }

    # Make group into a list with control and sample
    group = sampleTable[,"group"]
    group2 = list()
    group2[["c"]] = which(group == "c")
    group2[["s"]] = which(group == "s")

    group = group2
    print(paste("*** detected group c::",  paste(group[["c"]], collapse = " ") , "***"))
    print(paste("*** detected group s::",  paste(group[["s"]], collapse = " ") , "***"))



    ###########################################################
    # Get the sampleNames
    sampleNames = c()
    if( is.null(sampleTable$sampleName) ){
        stop( "The sample Table must have a column named sampleName" )
    }else if( length(unique( sampleTable$sampleName)) != length( sampleTable$sampleName) ){
        stop( "SampleName column must be unique" )
    }else{
        sampleNames = as.character( sampleTable$sampleName )

        print(paste("*** detected ", paste(sampleNames, collapse = " "), " sample Names ***"))
    }



    ###########################################################
    # Read in the  hyb files
    ###########################################################
    #load the files into a list
    print(" ***** Reading Hyb Files ******")

    hybFiles = list()
    hybFiles[[ "all" ]] = list()
    hybFiles[[ "all" ]][[ "all" ]] = list()

    for(i in 1:nrow( sampleTable )){

        #get file and path
        file =  as.character( sampleTable$file[i] )
        print( file )

        # Read in
        sampleHyb = read.table( file ,
                                header = F,
                                stringsAsFactors = F )

        #check the hyb file column names
        colnamesHyb = c("V1", "V2", "V3", "V4", "V5",
                        "V6", "V7", "V8", "V9", "V10",
                        "V11", "V12", "V13", "V14", "V15")

        if( !( identical(colnames(sampleHyb), colnamesHyb) ) ){
            stop(" The input hyb files do not look they are produced with the
                 hyb program. ")
        }

        # Store
        hybFiles[[ "all" ]][[ "all" ]][[ sampleNames[i] ]] = unique( sampleHyb )
        print(nrow(hybFiles[[ "all" ]][[ "all" ]][[ sampleNames[i] ]] ))
    }


    ###########################################################
    # Change the hyb files to have specific rna of interest
    # and with host and without
    ###########################################################
    print(" ***** Getting RNAs of Interest ******")
    # Get the rna of interest it comes in two ways, with host and without
    for(i in 1:length(rnas)){
        print(" *** RNA of interest + Host RNA ***")
        hybFiles[[ rnas[ i ] ]][[ "original"]] = swapHybs(hybList = hybFiles[[ "all" ]][[ "all" ]],
                                                          rna = rnas[ i ] )

        hybFiles[[ rnas[ i ] ]][[ "host"]] = swapHybs3(hybList = hybFiles[[ "all" ]][[ "all" ]],
                                                       rna = rnas[ i ] )
        print(" *** RNA of interest Alone ***")
        hybFiles[[ rnas[ i ] ]][[ "noHost"]] = swapHybs2(hybList = hybFiles[[ "all" ]][[ "all" ]],
                                                         rna = rnas[ i ] )
    }


    ###########################################################
    # Make matrices of the specific RNA without host
    ###########################################################
    print(" ***** Making Matrices ******")

    matrixList = list()
    c = 1
    for(i in rnas){
        print(i)
        matrixList[[i]][[ "noHost" ]] = list()
        matrixList[[i]][[ "noHost" ]] = getMatrices(hybFiles[[ i  ]][[ "noHost"]],
                                                    i, rnaSize[c])
        names(matrixList[[i]][[ "noHost" ]]) = sampleNames

        matrixList[[i]][[ "original" ]] = list()
        matrixList[[i]][[ "original" ]] = getMatrices(hybFiles[[ i  ]][[ "original"]],
                                                      i, rnaSize[c])
        names(matrixList[[i]][[ "original" ]]) = sampleNames
        c = c +1
    }



    ###########################################################
    # Make object
    ###########################################################
    print(" *** Creating object ***")
    #create comrades dataset object
    object  = new("comradesDataSet",
                  rnas = rnas,
                  hybDir = hybDir,
                  sampleTable = sampleTable,
                  hybFiles = hybFiles,
                  matrixList = matrixList,
                  group = group,
                  sampleNames = sampleNames)

    return(object)


}



